#!/usr/bin/env bash

# Save changes for later retrieval
function save() {
  local status=""
  git add "$(git rev-parse --show-toplevel)"
  git commit -m "Saved changes for $1" >/dev/null
  if [[ $? == 0 ]]; then
    status="*"
    git tag -f "gff-$1" >/dev/null
  fi
  echo "Previous HEAD was $1$status, $(git log --format='%s' -n 1 $1)"
}

# Restore previously-saved changes
function restore() {
  local status=""
  save "$(git rev-parse --short HEAD)"
  git checkout "gff-$1" 2>/dev/null
  if [[ $? == 0 ]]; then
    status="*"
    local patch="$(git format-patch HEAD^ --stdout)"
    git checkout HEAD^ 2>/dev/null
    echo "$patch" | git apply -
  else
    git checkout "$1" 2>/dev/null
  fi
  echo "HEAD is now $1$status, $(git log --format='%s' -n 1 $1)"
}

# Clean (permanently) current changes.
function clean() {
  local current_sha="$(git rev-parse --short HEAD)"
  local repo_root="$(git rev-parse --show-toplevel)"
  git reset HEAD "$repo_root" >/dev/null
  git clean -f -d -q -- "$repo_root" >/dev/null
  git checkout -- "$repo_root" >/dev/null
  git tag -d "gff-$current_sha" &>/dev/null
  if [[ $? == 0 ]]; then
    echo "Removed stored data for commit $current_sha"
  else
    echo "No stored data for commit $current_sha"
  fi
}

function prev() {
  restore "$(git rev-parse --short HEAD^)"
}

function next() {
  local branch="master"
  local next_sha=$(git log --format='%h' --reverse --ancestry-path HEAD.."$branch" | head -n 1)
  # Abort if no more commits
  if [[ ! "$next_sha" ]]; then
    echo "Already at last commit in $branch!"
    return 1
  fi
  restore "$next_sha"
}

if [[ "$1" == "clean" ]]; then
  clean
elif [[ "$1" == "prev" ]]; then
  prev
else
  next
fi

# local next_sha=$(git log --format='%h' --reverse "$branch" | awk "/^$current_sha/{getline; print}")

# # Remove untracked files and directories
# local repo_root="$(git rev-parse --show-toplevel)"
# git clean -f -d -q -- "$repo_root"
# # Revert changes in tracked files
# git checkout -- "$repo_root"


# gff-save "$(git rev-parse --short HEAD)"
# Checkout branch specifically if next SHA is the branch's SHA
# if [[ "$next_sha" == "$(git rev-parse --short $branch)" ]]; then
#   next_sha="$branch"
# fi
# git checkout "$next_sha"
